worker_processes  1;
daemon off;

error_log  stderr warn;
pid        {{pidfile}};

events {
  worker_connections  1024;
}


http {

  log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
  access_log  /dev/stdout main;

  default_type  application/octet-stream;
  # Large numbers of vhosts means super-size hash size
  server_names_hash_max_size 32768;
  # vhost names are a bit long too
  server_names_hash_bucket_size 256;
  sendfile        on;
  keepalive_timeout  65;
  client_max_body_size 1G;

  gzip on;
  # Disabled because Travis CI fails. Not strictly necessary, given few clients
  # lack gzip support these days.
  #gunzip on;
  gzip_proxied any;
  gzip_types text/css application/javascript application/json;

  client_body_temp_path {{tmpdir}};
  proxy_temp_path {{proxydir}};

  proxy_cache_path {{cachedir}} keys_zone=auth:128m;
  proxy_cache_key "$scheme$host$request_uri";

  index   index.html index.htm;

  map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
  }

  map $http_x_forwarded_proto $user_proto {
    default $http_x_forwarded_proto;
    '' $scheme;
  }

  {{#tls}}
  ssl_certificate       {{certificate}};
  ssl_certificate_key   {{key}};
  ssl_protocols         TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA';
  ssl_prefer_server_ciphers on;
  ssl_session_cache     shared:SSL:1m;
  {{/tls}}

  {{#extraconf}}
  {{{extraconf}}}
  {{/extraconf}}

  # Relative redirects shouldn't include the listening port, which likely isn't
  # the same as the one seen publicly.
  port_in_redirect off;

  server {
    listen       *:{{port}} {{#tls}}ssl http2{{/tls}};
    server_name  _;

    location / {
      auth_request /auth;
      auth_request_set $upstreamServer  $upstream_http_x_target_upstream;
      auth_request_set $serverName      $upstream_http_x_server_name;
      auth_request_set $parentRedirect  $upstream_http_x_parent_host;
      auth_request_set $routingResponseTime  $upstream_response_time;
      # Otherwise forbidden means service is unavailable
      error_page 403 = @error;
      proxy_pass $upstreamServer;
      proxy_http_version 1.1; # Need to stream image downloads
      proxy_buffering off;
      proxy_read_timeout 1d; # Allow websockets to idle
      add_header X-Compute-Time $upstream_header_time;
      add_header X-Routing-Time $routingResponseTime;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;
      proxy_set_header X-Forwarded-Proto $user_proto;
      proxy_set_header X-Forwarded-Host $http_host;
      proxy_set_header X-Server-Name    $serverName;
    }

    location = /auth {
      internal;
      proxy_pass {{authserver}};
      proxy_cache auth;
      # Cache successful lookups, but not failures
      proxy_cache_valid 200 1m;
      proxy_cache_valid 403 0;
      proxy_pass_request_body off;
      proxy_set_header Host $host;
      proxy_set_header Content-Length "";
    }

    location @error {
      internal;
      if ($parentRedirect) {
        return 302 $scheme://$parentRedirect/waiting/$scheme/$http_host$request_uri;
      }
      return 499;
    }
  }
}
